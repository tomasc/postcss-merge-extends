// Generated by CoffeeScript 2.3.2
(function() {
  var discardEmpty, getFirstPlaceholderCommentNode, getPlaceholderContent, getPlaceholderName, getPlaceholderNames, getPlaceholderSelectors, hasPlaceholderName, isExtendEnd, isExtendStart, postcss, removePlaceholders,
    indexOf = [].indexOf;

  postcss = require('postcss');

  module.exports = postcss.plugin('postcss-merge-extends', function(opts) {
    opts = opts || {};
    return function(root, result) {
      var commentNode, i, j, len, len1, name, newNode, placeholderContent, placeholderSelectors, ref, rule;
      ref = getPlaceholderNames(root);
      for (i = 0, len = ref.length; i < len; i++) {
        name = ref[i];
        if (commentNode = getFirstPlaceholderCommentNode(root, name)) {
          placeholderContent = getPlaceholderContent(commentNode);
          placeholderSelectors = getPlaceholderSelectors(root, name);
          newNode = commentNode.parent.clone();
          newNode.selector = placeholderSelectors.join(', ');
          newNode.removeAll();
          for (j = 0, len1 = placeholderContent.length; j < len1; j++) {
            rule = placeholderContent[j];
            newNode.append(rule);
          }
          commentNode.parent.before(newNode);
        }
        removePlaceholders(root, name);
        root.each(discardEmpty);
      }
    };
  });

  isExtendStart = function(node) {
    if (node.type !== 'comment') {
      return;
    }
    return /placeholder\:start/.test(node.text);
  };

  isExtendEnd = function(node) {
    if (node.type !== 'comment') {
      return;
    }
    return /placeholder\:end/.test(node.text);
  };

  hasPlaceholderName = function(node, name) {
    if (!isExtendStart(node)) {
      return;
    }
    return new RegExp(name).test(node.text);
  };

  getPlaceholderName = function(node) {
    if (!isExtendStart(node)) {
      return;
    }
    return node.text.split('%')[1];
  };

  getFirstPlaceholderCommentNode = function(root, name) {
    var res;
    res = null;
    root.walkComments(function(comment) {
      if (hasPlaceholderName(comment, name) && res === null) {
        res = comment;
      }
    });
    return res;
  };

  getPlaceholderSelectors = function(root, name) {
    var res;
    res = [];
    root.walkComments(function(comment) {
      if (hasPlaceholderName(comment, name)) {
        return res.push(comment.parent.selector);
      }
    });
    return res;
  };

  getPlaceholderContent = function(node) {
    var nextNode, res;
    if (!isExtendStart(node)) {
      return;
    }
    res = [];
    nextNode = node.next();
    while (nextNode && !isExtendEnd(nextNode)) {
      res.push(nextNode);
      nextNode = nextNode.next();
    }
    return res;
  };

  getPlaceholderNames = function(root) {
    var res;
    res = [];
    root.walkComments(function(comment) {
      var name;
      if (isExtendStart(comment)) {
        name = getPlaceholderName(comment);
        if (indexOf.call(res, name) < 0) {
          return res.push(name);
        }
      }
    });
    return res;
  };

  removePlaceholders = function(root, name) {
    return root.walkComments(function(comment) {
      var _nextNode, nextNode;
      if (hasPlaceholderName(comment, name)) {
        nextNode = comment.next();
        comment.remove();
        while (nextNode && !isExtendEnd(nextNode)) {
          _nextNode = nextNode.next();
          nextNode.remove();
          nextNode = _nextNode;
        }
        if (isExtendEnd(nextNode)) {
          return nextNode.remove();
        }
      }
    });
  };

  discardEmpty = function(node) {
    var params, sub, type;
    type = node.type;
    sub = node.nodes;
    params = node.params;
    if (sub) {
      node.each(discardEmpty);
    }
    if ((type === 'decl' && !node.value) || (type === 'rule' && !node.selector || sub && !sub.length) || (type === 'atrule' && (!sub && !params || !params && !sub.length))) {
      return node.remove();
    }
  };

}).call(this);
